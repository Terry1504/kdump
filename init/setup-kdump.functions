# setup-kdump.functions
#
# (c) 2014, Petr Tesarik <ptesarik@suse.de>, SUSE LINUX Products GmbH
#
# Helper functions needed to set up kdump initrd.
#

#
# Paths and other configuration variables
#

CONFIG=/etc/sysconfig/kdump

#
# Checks whether there is a device in the system which is handled
# by the specified module.
# Parameters:
#   1) modname: kernel module name
# Exit status:
#   zero     if a matching device was found
#   non-zero otherwise
function kdump_module_has_device()					   # {{{
{
    local modname="$1"
    local -a aliaslist
    local line

    while read line; do
	aliaslist[${#aliaslist[@]}]="$line"
    done < <(modinfo -k "$kernel_version" -F alias "$modname" 2>/dev/null)

    # for each device in the system, check the device modalias file ...
    find /sys/devices -type f -name modalias -print0 | xargs -0 cat | \
    (
	while read line; do
	    # ... against each modalias of the checked module
	    for modalias in "${aliaslist[@]}"; do
		case "$line" in
		    $modalias)
			exit 0
			;;
	        esac
	    done
	done
	exit 1
    )
}									   # }}}

# Extract the device name from a route
#
# Input:
#   output of "route show"
# Output:
#   device name (for each line of input)
function kdump_route2dev()						   # {{{
{
    sed -n 's/.* dev \([^ ]*\) *.*/\1/p'
}									   # }}}

#
# Get a wicked configuration value for a device
#
# Parameters:
#   1) ifname  network interface name
#   2) conf    configuration XPath under /interface
# Output:
#   configuration value
function kdump_wicked_conf()						   # {{{
{
    local ifname="$1"
    local conf="$2"

    wicked show-config | wicked xpath "%{/interface[name='$ifname']/$conf}"
}									   # }}}

#
# Determine the default network device.
#
# Output:
#   ifname  default network interface name (or empty if none)
function kdump_default_netdev()						   # {{{
{
    local ifname
    local inffile="/etc/install.inf"

    # check current default routes
    ifname=$(ip route show 0/0 | kdump_route2dev)
    if [ -z "$ifname" ] ; then
	ifname=$(ip -6 route show ::/0 | kdump_route2dev)
    fi

    # if not found, get info from install.inf
    if [ -z "$ifname" -a -f "$inffile" ] ; then
	local dev hwaddr hwaddr2
	eval $( sed -ne '
		s/^Netdevice: \(.*\)/ifname=\1/p;
		s/HWAddr: \(.*\)/hwaddr=\1/p' \
	    "$inffile" )
        if [ -n "$hwaddr" ] ; then
            for dev in /sys/class/net/* ; do
                read hwaddr2 < "$dev"/address
                if [ "$hwaddr" = "$hwaddr2" ] ; then
                    ifname="${dev##*/}"
                fi
            done
        fi
    fi
    echo "$ifname"
}									   # }}}

# Get the underlying physical devices of a bridge.
#
# Virtual devices (tap or vif) are ignored.
#
# Parameters:
#   1) ifname  bridge interface name
# Output:
#   ifnames  list of underlying physical interfaces;
function kdump_bridge_phys_dev()					   # {{{
{
    local ifname="$1"

    if [ -d "/sys/class/net/$ifname/bridge" -a \
            -d "/sys/class/net/$ifname/brif" ] ; then

        local ifname2 count=0
        local -a res
        for ifname2 in "/sys/class/net/$ifname/brif"/*; do
            case "$(readlink -f "$ifname2")" in
            /sys/devices/virtual/*)
                continue
            esac
            res[count]="${ifname2##*/}"
            count=$(( count+1 ))
        done
        ifname=${res[@]}
    fi

    echo "$ifname"
}									   # }}}

#
# Determine the default network mode of a given device.
#
# Parameters:
#   1) ifname  network interface name
# Output:
#   mode    initialization mode ("static" or "dhcp")
function kdump_netdev_mode()						   # {{{
{
    local ifname="$1"
    local inffile="/etc/install.inf"
    local BOOTPROTO

    # get mode using wicked if possible
    if [ -n "$(type -P wicked)" -a \
	"$(kdump_wicked_conf "$ifname" name)" = "$ifname" ]
    then
	local dhcpv4=$(kdump_wicked_conf "$ifname" ipv4:dhcp/enabled)
	local dhcpv6=$(kdump_wicked_conf "$ifname" ipv6:dhcp/enabled)
	if [ "$dhcpv4" = true -o "$dhcpv6" = true ] ; then
	    BOOTPROTO=dhcp
	else
	    BOOTPROTO=static
	fi
    fi

    # get mode from config files
    if [ -z "$BOOTPROTO" ] ; then
	local cfg=/etc/sysconfig/network/ifcfg-"$ifname"
	if [ -f "$cfg" ] ; then
	    eval $(grep '^[[:space:]]*BOOTPROTO=' "$cfg")
	fi
    fi

    # try install.conf
    if [ -z "$BOOTPROTO" ] ; then
	eval $( sed -ne 's/^NetConfig: \(.*\)/BOOTPROTO=\1/p;' \
	    "$inffile" )
    fi

    # if not found, look if there is a dhcp daemon for the interface
    if [ -z "$BOOTPROTO" ] ; then
        if [ -n "$(ps -C dhclient,dhclient6,dhcpcd -o cmd= |
		    sed -n '/.* \('"$ifname"'\)\( .*\|$\)/p' )" ] ; then
            BOOTPROTO=dhcp
        else
            BOOTPROTO=static
        fi
    fi

    echo "$BOOTPROTO"
}									   # }}}

#
# Get the ifname parameter for a given device
#
# Parameters:
#   1) device  device name
# Output:
#   ifname corresponding ifname= initrd parameter (or empty)
function kdump_ifname_config()						   # {{{
{
    local iface="$1"
    local hwaddr=$(<"/sys/class/net/$iface/address")
    [ -n "$hwaddr" ] && echo "ifname=$iface:$hwaddr"
}									   # }}}

#
# Convert a CIDR prefix to IPv4 netmask
#
# Parameters:
#   1) prefix the CIDR prefix (default: 32)
# Output:
#   Corresponding netmask
kdump_prefix2netmask() {						   # {{{
    local prefix="${1:-32}"
    local netmask=
    local i
    for i in a b c d
    do
	netmask="$netmask.$(( 255 - (255 >> prefix) ))"
	if [ "$prefix" -gt 8 ] ; then
	    prefix=$(( prefix - 8 ))
	else
	    prefix=0
	fi
    done
    echo "${netmask:1}"
}									   # }}}

#
# Get the IPv4 ip= parameter for a given device
#
# Parameters:
#   1) device  device name
# Output:
#   ip configuration string that can be used for the ip= initrd parameter
function kdump_ip_config()						   # {{{
{
    local iface="$1"
    local ipaddr peeraddr gwaddr netmask hostname
    local family cidr rest
    local prefix
    while read family cidr rest
    do
	[ "$family" = "inet" ] || continue

	ipaddr="${cidr%/*}"
	prefix="${cidr:${#ipaddr}}"
	set -- $rest

        if [ "$1" == "peer" ] ; then
	    cidr="$2"
            peeraddr=${cidr%/*}
	    prefix="${cidr:${#peeraddr}}"
	    shift 2
        fi
	netmask=$( kdump_prefix2netmask "${prefix:1}" )

    done < <(ip -4 address show dev "$iface")

    gwaddr=$(ip route show 0/0 | sed -n 's/.* via \([^ ]*\).*/\1/p')
    hostname=$(hostname)

    echo "ip=$ipaddr:$peeraddr:$gwaddr:$netmask:$hostname:$iface:none"
}									   # }}}

#
# Get the IPv6 ip= parameter for a given device
#
# Parameters:
#   1) device  device name
# Output:
#   ip configuration string that can be used for the ip= initrd parameter
function kdump_ip6_config()						   # {{{
{
    local iface="$1"
    local ipaddr peeraddr gwaddr hostname
    local family cidr rest prefix

    hostname=$(hostname)
    gwaddr=$(ip -6 route show ::/0 | sed -n 's/.* via \([^ ]*\).*/[\1]/p')

    while read family cidr rest
    do
	[ "$family" = "inet6" ] || continue

	ipaddr="${cidr%/*}"
	prefix="${cidr:${#ipaddr}}"
	ipaddr="[$ipaddr]$prefix"
	set -- $rest

        if [ "$1" == "peer" ] ; then
	    peeraddr="${2%/*}"
	    prefix="${2:${#peeraddr}}"
	    peeraddr="[$peeraddr]"
	else
	    peeraddr=
        fi

	echo "ip=$ipaddr:$peeraddr:$gwaddr::$hostname:$iface:none"
    done < <(ip -6 address show dev "$iface" permanent scope global)
}									   # }}}

#
# Get the save directory and protocol.
#
# Output variables:
#   kdump_$name[]  $name as returned by kdumptool print_target, e.g.:
#       kdump_URL[]
#       kdump_Protocol[]
#       kdump_Realpath[]
#   kdump_max      maximum index in kdump_*[]
# Exit status:
#   zero     on success
#   non-zero if kdumptool didn't return any targets
function kdump_get_targets()						   # {{{
{
    kdump_max=0

    # add /boot and /usr/lib/debug/boot if needed
    if [ "$KDUMP_COPY_KERNEL" = "yes" ] ; then
	kdump_Protocol[kdump_max]=srcfile
	kdump_Realpath[kdump_max]=/boot/
	kdump_URL[kdump_max]=boot
	kdump_max=$((kdump_max + 1))
    fi

    eval "$( kdumptool print_target | \
        sed -e "s/'/'\\\\''/g" \
	    -e 's/^$/max=$((kdump_max+1))'\''/' \
	    -e 's/^/kdump_/' \
	    -e "s/: */[\$kdump_max]='/" \
	    -e "s/\$/\'/" )"
    if [ ${#kdump_URL[@]} -eq 0 ] ; then
	echo >&2 "kdumptool print_target failed."
	return 1
    fi
    return 0
}									   # }}}

#
# Print array content so that it can be used as bash input
#
# Parameters:
#   1) name  array variable to be printed
# Output:
#   shell code that can be passed to eval to restore the array
function kdump_print_array()
{
    local name="$1"
    local i
    echo -n "( "
    for i in $(eval printf \"%q \" \"\${!$name[@]}\")
    do
	printf "[%s]=%q " "$i" "$(eval echo \"\${$name[i]}\")"
    done
    echo ")"
}

#
# Export kdump_*[] arrays, returned by kdump_get_targets.
#
# Input variables:
#   kdump_URL[], kdump_Protocol[], kdump_Host[], kdump_Realpath,
#   kdump_mnt[]
# Output variables (exported):
#   KDUMP_x_URL, KDUMP_x_Protocol, KDUMP_x_Host, KDUMP_x_Realpath,
#   KDUMP_x_mnt
function kdump_export_targets()						   # {{{
{
    export KDUMP_x_URL=$( kdump_print_array kdump_URL )
    export KDUMP_x_Protocol=$( kdump_print_array kdump_Protocol )
    export KDUMP_x_Host=$( kdump_print_array kdump_Host )
    export KDUMP_x_Realpath=$( kdump_print_array kdump_Realpath )
    export KDUMP_x_mnt=$( kdump_print_array kdump_mnt )
    export kdump_max
}									   # }}}

#
# Import kdump_*[] arrays from environment.
#
# Input/Output Variables:
#   reverse of kdump_export_arrays
function kdump_import_targets()						   # {{{
{
    eval "kdump_URL=$KDUMP_x_URL"
    eval "kdump_Protocol=$KDUMP_x_Protocol"
    eval "kdump_Host=$KDUMP_x_Host"
    eval "kdump_Realpath=$KDUMP_x_Realpath"
    eval "kdump_mnt=$KDUMP_x_mnt"
    test ${#kdump_URL[@]} -gt 0
}									   # }}}

#
# Read and normalize /etc/fstab and /proc/mounts (if exists).
# The following transformations are done:
#   - initial TABs and SPACEs are removed
#   - empty lines and comments are removed
#   - fields are separated by a single TAB
# Output:
#   Cleaned up fstab and /proc/mounts
function kdump_read_mounts()						   # {{{
{
    local proc_mounts=/proc/mounts
    test -e "$proc_mounts" || proc_mounts=
    sed -e 's/[ \t][ \t]*/\t/g;s/^\t//;/^$/d;/^#/d' \
        /etc/fstab "$proc_mounts"
}									   # }}}

#
# Update the kdump mountpoint corresponding to the non-kdump mountpoint.
# If necessary, add a new entry into the kdump_* arrays.
#
# Parameters:
#   1) device         mount device
#   2) mountpoint     mountpoint in non-kdump environment
#   3) fstype         filesystem type
#   4) opts           mount options
# Output variable:
#   kdump_mountidx    mountpoint index in kdump environment
# Input/output variables:
#   kdump_mnt[]
# Output variables:
#   kdump_dev[]
#   kdump_fstype[]
#   kdump_opts[]
function kdump_update_mount()						   # {{{
{
    local device="$1"
    local mountpoint="/kdump/mnt0/${2#/}"
    local fstype="$3"
    local opts="$4"
    local mnt i

    i=0
    for mnt in "${kdump_mnt[@]}"
    do
	[ "$mnt" = "${mountpoint%/}" ] && break
        i=$((i+1))
	mountpoint="/kdump/mnt$i/${mountpoint#/kdump/mnt*/}"
    done

    kdump_mnt[i]="${mountpoint%/}"
    kdump_dev[i]="$device"
    kdump_fstype[i]="$fstype"
    kdump_opts[i]="$opts"

    kdump_mountidx=$i
}									   # }}}

#
# Get kdump mount points and map between running system and kdump system
#
# Mount point 0 always corresponds to the "/boot" mount point and may be
# empty if "/boot" is not on a separate partition.
#
# Input variables:
#   KDUMP_COPY_KERNEL  config option, see kdump(5)
# Output variables:
#   kdump_*         target specs (as returned by kdump_get_targets)
#   kdump_mnt[i]    mountpoint i in kdump environment
#   kdump_dev[i]    mount device for mount i
#   kdump_fstype[i] file system type for mount i
#   kdump_opts[i]   mount options for mount i
function kdump_get_mountpoints()					   # {{{
{
    local device mountpoint filesystem opts dummy
    local protocol realpath kdump_mountidx
    local -a curmp mntdev mntfstype mntopts
    local i

    # Populate kdump_*[] arrays with dump target info
    kdump_get_targets || return 1

    kdump_mnt=( )
    kdump_dev=( )
    kdump_fstype=( )
    kdump_opts=( )

    while read device mountpoint filesystem opts dummy ; do
	i=0
	while [ $i -le $kdump_max ] ; do
            protocol="${kdump_Protocol[i]}"
            realpath="${kdump_Realpath[i]}"
            if [ \( "$protocol" = "file" -o "$protocol" = "srcfile" \) -a \
		"${realpath#$mountpoint}" != "$realpath" -a \
		"${#mountpoint}" -gt "${#curmp[i]}" ] ; then
		curmp[i]="$mountpoint"
		mntdev[i]="$device"
		mntfstype[i]="$filesystem"
		mntopts[i]="$opts"
            fi
            i=$((i+1))
	done
    done < <(kdump_read_mounts)

    # map running paths to target paths
    i=0
    while [ $i -le $kdump_max ] ; do
	mountpoint="${curmp[i]}"
	if [ -n "$mountpoint" ]; then
	    kdump_update_mount "${mntdev[i]}" "$mountpoint" \
		"${mntfstype[i]}" "${mntopts[i]}"
	    kdump_Realpath[i]="/mnt${kdump_mountidx}${kdump_Realpath[i]}"
	fi
	i=$((i+1))
    done

    return 0
}									   # }}}

#
# Get the kdump configuration
# Output variables (consult kdumptool for a complete list):
#   KDUMP_*
#   KEXEC_OPTIONS
#   MAKEDUMPFILE_OPTIONS
# Exit status:
#   zero     on success
#   non-zero if dump_config failed
function kdump_get_config()						   # {{{
{
    local kdump_config=$( kdumptool dump_config --format=shell )
    if [ $? -ne 0 ] ; then
	echo >&2 "kdump configuration failed"
	return 1
    fi

    eval "$kdump_config"
    return 0
}									   # }}}

#
# Create adjusted kdump configuration.
#
# Parameters:
#   1) dest: root of the temporary area
# Input variables:
#   KDUMP_* variables (as sourced from $CONFIG)
#   kdump_URL[]
#   kdump_Protocol[]
#   kdump_Host[]
#   kdump_Realpath[]
# Output variables:
#   KDUMP_SAVEDIR   re-created from kdump_* variables
#   KDUMP_HOST_KEY  default from ssh-keygen if not set previously
#   KDUMP_REQUIRED_PROGRAMS updated as necessary
#   kdump_over_ssh  non-empty if SSH is involved in dump saving
# Output:
#   "kdumptool dump_config" with some variables modified
function kdump_modify_config()						   # {{{
{
    local dest="${1%/}"
    #
    # Special handling for some protocols
    KDUMP_SAVEDIR=
    kdump_over_ssh=
    local copy_ssh=
    local i=0
    while [ $i -le $kdump_max ] ; do
	protocol="${kdump_Protocol[i]}"

	# replace original path with resolved path
	test -z "$KDUMP_SAVEDIR" || KDUMP_SAVEDIR="$KDUMP_SAVEDIR "
	if [ "$protocol" = "file" ] ; then
            KDUMP_SAVEDIR="${KDUMP_SAVEDIR}file://${kdump_Realpath[i]}"
	elif [ "$protocol" != "srcfile" ] ; then
            KDUMP_SAVEDIR="${KDUMP_SAVEDIR}${kdump_URL[i]}"
	fi

	#
	# get the host key, if needed
	if [ "$protocol" = "sftp" -o \
	     "$protocol" = "ssh" ] ; then
            kdump_over_ssh=yes
	    test "$protocol" = "ssh" && copy_ssh=ssh
            if [ -z "$KDUMP_HOST_KEY" ] ; then
		KDUMP_HOST_KEY=$(
		    ssh-keygen -F "$kdump_Host" 2>/dev/null | \
		    awk '/^[^#]/ { if (NF==3) { print $3; exit } }'
		)
            fi
	    ssh-keygen -F "$kdump_Host" 2> /dev/null \
		>>"${dest}/kdump/.ssh/known_hosts"
	fi

	i=$((i+1))
    done

    # copy ssh if needed
    if [ -n "$copy_ssh" ] ; then
	KDUMP_REQUIRED_PROGRAMS="$KDUMP_REQUIRED_PROGRAMS ssh"
    fi

    #
    # dump the configuration file, modifying:
    #   KDUMP_SAVEDIR  -> resolved path
    #   KDUMP_HOST_KEY -> target host public key
    kdumptool dump_config --format=shell | \
	KDUMP_SAVEDIR="$KDUMP_SAVEDIR" KDUMP_HOST_KEY="$KDUMP_HOST_KEY" \
	awk -F= '{
    id = $1
    sub(/^[ \t]*/, "", id)
    if (id in ENVIRON)
        print $1"=\""ENVIRON[id]"\""
    else
        print
}' > "${dest}${CONFIG}"
}									   # }}}

#
# Build a mapping between multipath devices and their wwid
# This map would be best stored in an associative array, but
# then bash 4.0+ would be needed (and SLES11 has bash 3.2).
#
# Output variables:
#   kdump_mpath_wwid_$major_$minor  wwid of the given major/minor device
function kdump_map_mpath_wwid()						   # {{{
{
    local f _dir _uuid _wwid _dev
    for f in /sys/block/*/dm/uuid ; do
	eval "_uuid=\$(<$f)" 2>/dev/null
	[[ "$_uuid" = mpath-* ]] || continue
	_dir="${f%/dm/uuid}"
	_wwid=$(<"$_dir"/dm/name)
	_dev=$(<"$_dir"/dev)
	eval kdump_mpath_wwid_${_dev/:/_}=\$_wwid
    done
}									   # }}}

#
# Keep only required devices in multipath.conf
#
# Parameters:
#   1) devices: list of all required devices (multipath.conf syntax)
# Output:
#   filtered multipath.conf
function kdump_modify_multipath()					   # {{{
{
    local -a wwids
    eval wwids="($1)"
    kdumptool multipath "${wwids[@]}" \
	< /etc/multipath.conf
}									   # }}}

#
# Copy SSH keys and create a config file in the target
# Parameters:
#   1) dest: root of the temporary area
function kdump_init_ssh()						   # {{{
{
    local dest="${1%/}"

    if [ -z "$KDUMP_HOST_KEY" ] ; then
        echo "WARNING: target SSH host key not found. " \
             "Man-in-the-middle attack is possible." >&2
    fi

    local ssh_conf="$dest/kdump/.ssh/config"
    echo "BatchMode yes" >> "$ssh_conf"
    echo "StrictHostKeyChecking yes" >> "$ssh_conf"
    echo "UserKnownHostsFile /kdump/.ssh/known_hosts" >> "$ssh_conf"

    local type
    for type in rsa dsa ecdsa ed25519
    do
	if [ -f /root/.ssh/id_${type} -a -f /root/.ssh/id_${type}.pub ] ; then
            cp /root/.ssh/id_${type}{,.pub} "${dest}/kdump/.ssh/"
	    if [ -f /root/.ssh/id_${type}-cert.pub ] ; then
		cp /root/.ssh/id_${type}-cert.pub "${dest}/kdump/.ssh/"
	    fi
	    echo "IdentityFile /kdump/.ssh/id_${type}" >> "$ssh_conf"
	fi
    done
}									   # }}}

#
# Create the /kdump hierarchy with mountpoints
# Parameters:
#   1) root:     initrd temporary root
# Input variables:
#   kdump_mnt[]  mountpoints in kdump environment
function kdump_init_dirs()						   # {{{
{
    local root="$1"
    local i d mnt

    mkdir -p "${root}/kdump"
    mkdir -m 01777 "${root}/kdump/tmp"
    mkdir -m 0700 "${root}/kdump/.ssh"

    for mnt in "${kdump_mnt[@]}"
    do
	mkdir -p "${root}$mnt"
    done

    for i in "${!kdump_Protocol[@]}"
    do
	[ "${kdump_Protocol[i]}" = "srcfile" ] || continue

	d="${kdump_Realpath[i]}"
	ln -snf "${d#/}" "${root}/kdump/${kdump_URL[i]}"
    done
}

#
# Set up or create all necessary files
# Parameters:
#   1) outdir:    initrd temporary root
#   2) mpathdevs: space-separated list of all multipath devices required
#                 by kdump (using multipath.conf syntax)
# Input variables:
#   KDUMP_*      see kdump_get_config
#   kdump_mnt[]  mountpoints in kdump environment
# Output variables:
#   KDUMP_REQUIRED_PROGRAMS updated as necessary
function kdump_setup_files()						   # {{{
{
    local outdir="${1%/}"
    local mpathdevs="$2"
    local kdump_over_ssh

    #
    # initialize the /kdump hierarchy
    #
    kdump_init_dirs "$outdir"

    #
    # create target configuration
    #
    mkdir -p "${outdir}${CONFIG%/*}"
    kdump_modify_config "$outdir"

    #
    # remember the host name
    #
    hostname >> "${outdir}/etc/hostname.kdump"

    #
    # copy public and private key if needed
    #
    if [ -n "$kdump_over_ssh" ] ; then
	kdump_init_ssh "$outdir"
    fi

    #
    # create modified multipath.conf
    #
    if [ -e /etc/multipath.conf ] ; then
	kdump_modify_multipath "$mpathdevs" > "${outdir}/etc/multipath.conf"
    fi

    return 0
}									   # }}}
